using System.Threading;
using Cysharp.Threading.Tasks;
using Sirenix.OdinInspector;
using Sirenix.Utilities;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Exploratorium.Frontend
{
    public abstract class Openable : UIBehaviour, IOpenable
    {
        [Tooltip("Base duration of all animations generated by this component")]
        [BoxGroup("Animation"), SerializeField, Min(0)]
        private float duration = 1f;

        [Tooltip("Delay before any open-animation is started")]
        [BoxGroup("Animation"), SerializeField, Min(0)]
        private float delayOpen = 1f;

        [Tooltip("Delay before any close-animation is started")]
        [BoxGroup("Animation"), SerializeField, Min(0)]
        private float delayClose = 0;

        [Tooltip(
            "On start, the component will be initialized to its open state when true, to its closed state otherwise")]
        [BoxGroup("State")][SerializeField] private bool startOpen = true;

        [Tooltip("When true the component will be initialized to its Start Open state when enabled")]
        [BoxGroup("State")][SerializeField] private bool restartOnEnable = true;

        [Tooltip("Signals received by this component will be passed on to these openables")] [SerializeField]
        protected Openable[] cascade;

        [BoxGroup("Fixes")]
        [InfoBox(
            "The number of frames to wait on Start before building the initial tweens. This should be set to 1 in most cases.")]
        [Min(1)] [SerializeField]
        private int waitFrames = 1;

        [Tooltip("Whether to show detailed debug messages")]
        [SerializeField] protected bool debug;

        private CancellationTokenSource _cts = new CancellationTokenSource();

        [ShowInInspector, ReadOnly]
        private bool _isDirty = true;

        private bool _isReady = false;
        private bool _isOpen = false;
        private float _addOpenDelay;
        private float _addCloseDelay;
        private float _addDuration;

        protected override void Awake()
        {
            Debug.Assert(!debug, "!debug", this);
            base.Awake();
        }

        protected override void Start()
        {
            _isOpen = startOpen;
        }

        protected override void OnEnable()
        {
            if (restartOnEnable)
                _isOpen = startOpen;

            // we assume that anything can happen before the component is enabled, particularly layout
            // changes, so we queue a tween rebuild.
            SetDirty();
            InitAsync(_cts.Token).Forget();
        }

        private async UniTask InitAsync(CancellationToken ct)
        {
            // we delay creation of tweens by at least the remainder of the frame when the component becomes enabled
            // to allow all actions that may affect this components tween generator to do their thing, particularly
            // layout groups that get triggered after multiple children get added to them.

            _isReady = false;
            for (int i = 0; i < waitFrames; i++) // will be at least one
                await UniTask.NextFrame(PlayerLoopTiming.PreUpdate, ct);

            // we don't force here in case Rebuild was called from the outside intermittently which we expect to be
            // deliberate and we don't want to interfere with that.
            RebuildTweens(false);
            _isReady = true;
            if (debug) Debug.Log($"{nameof(OpenableText)} : {name} is ready", this);
        }

        /// <summary>
        /// This is the total duration including any <see cref="SetAdditionalDuration"/>.
        /// </summary>
        public float Duration
        {
            get => duration + _addDuration;
            /*set
            {
                duration = Mathf.Max(0, value);
                SetDirty();
            }*/
        }

        /// <summary>
        /// This is the total close-delay including any <see cref="SetAdditionalCloseDelay"/>.
        /// </summary>
        public float CloseDelay
        {
            get => delayClose + _addCloseDelay;
            /*set
            {
                delayClose = Mathf.Max(0, value);
                SetDirty();
            }*/
        }

        /// <summary>
        /// This is the total open-delay including any <see cref="SetAdditionalOpenDelay"/>.
        /// /// </summary>
        public float OpenDelay
        {
            get => delayOpen + _addOpenDelay;
            /*set
            {
                delayOpen = Mathf.Max(0, value);
                SetDirty();
            }*/
        }

        public void SetDirty()
        {
            _isDirty = true;
        }

        /// <summary>
        /// After setting this, call <see cref="RebuildTweens"/>
        /// </summary>
        public void SetAdditionalOpenDelay(float delay)
        {
            _addOpenDelay = delay;
            SetDirty();
        }

        /// <summary>
        /// After setting this, call <see cref="RebuildTweens"/>
        /// </summary>
        public void SetAdditionalCloseDelay(float delay)
        {
            _addCloseDelay = delay;
            SetDirty();
        }

        /// <summary>
        /// After setting this, call <see cref="RebuildTweens"/>
        /// </summary>
        public void SetAdditionalDuration(float duration)
        {
            _addDuration = duration;
            SetDirty();
        }

        public bool IsReady => _isReady;

        public int OpenCount { get; private set; }

        public bool IsOpen => _isOpen;

        public bool IsDirty => _isDirty;

        public async UniTaskVoid CloseAsync()
        {
            if (!IsReady)
            {
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : CloseAsync, awaiting readiness of {name}", this);
                await UniTask.WaitUntil(() => IsReady, PlayerLoopTiming.Update, _cts.Token);
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : CloseAsync, continue on ready signal of {name}", this);
            }

            if (!_isOpen)
            {
                if (debug) Debug.LogWarning($"{nameof(OpenableGroup)} : CloseAsync ignored on {name}; Already closed", this);
                return;
            }

            cascade.ForEach(it => it.CloseAsync().Forget());
            OnCloseAsync().Forget();
            _isOpen = false;
        }
        
        public async UniTaskVoid CycleAsync()
        {
            if (!IsReady)
            {
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : CloseAsync, awaiting readiness of {name}", this);
                await UniTask.WaitUntil(() => IsReady, PlayerLoopTiming.Update, _cts.Token);
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : CloseAsync, continue on ready signal of {name}", this);
            }

            cascade.ForEach(it => it.CycleAsync().Forget());
            OnCycleAsync().Forget();
        }

        protected abstract UniTaskVoid OnCloseAsync();
        protected abstract UniTaskVoid OnCycleAsync();


        [Button, HorizontalGroup("Debug Buttons")]
        private void OpenNow() => OpenAsync().Forget();
        
        [Button, HorizontalGroup("Debug Buttons")]
        private void CloseNow() => CloseAsync().Forget();
        
        public async UniTaskVoid OpenAsync()
        {
            if (!IsReady)
            {
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : OpenAsync, awaiting readiness of {name}", this);
                await UniTask.WaitUntil(() => IsReady, PlayerLoopTiming.Update, _cts.Token);
                if (debug) Debug.Log($"{nameof(OpenableGroup)} : OpenAsync, continue on ready signal of {name}", this);
            }

            if (_isOpen)
            {
                if (debug)
                    Debug.LogWarning($"{nameof(OpenableGroup)} : OpenAsync ignored on {name}; Already open", this);
                return;
            }

            cascade.ForEach(it => it.OpenAsync().Forget());
            OnOpenAsync().Forget();
            OpenCount++;
            _isOpen = true;
        }

        protected abstract UniTaskVoid OnOpenAsync();

        public void RebuildTweens(bool force)
        {
            if (_isDirty || force)
            {
                OnRebuildTweens();
            }
            else
            {
                if (debug) Debug.Log($"{nameof(Openable)} : Rebuild request on '{name}' ignored, not dirty.", this);
            }

            _isDirty = false;
        }

        protected abstract void OnRebuildTweens();

        [Button]
        public void RebuildTweensImmediately() => RebuildTweens(true);

        protected override void OnDestroy()
        {
            _cts.Cancel();
        }

        public void Toggle()
        {
            if (_isOpen)
                Close();
            else
                Open();
        }
        
        public async UniTaskVoid ToggleAsync()
        {
            if (_isOpen)
                CloseAsync().Forget();
            else
                OpenAsync().Forget();
            await UniTask.CompletedTask;
        }

        public void Open() => UniTask.Void(OpenAsync);

        public void Close() => UniTask.Void(CloseAsync);
    }
}